1. 产品定义
一个名为 "Obsidian Web Clipper & Assistant" 的工具组合。它允许用户在浏览网页时，零摩擦地将网页正文、高亮笔记、以及 AI 生成的深度总结，一键保存到本地 Obsidian 知识库中。

| 模块       | 功能点        | 详细描述                                                     | 验收标准                                                     |
| ---------- | ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 内容提取   | 正文清洗      | 去除广告、侧边栏、弹窗，仅保留文章核心内容。                 | 效果对标 Safari 阅读模式。                                   |
|            | Markdown 转换 | 将 HTML 转换为标准 Markdown 格式。                           | 标题层级正确，列表、代码块、引用格式保留。                   |
|            | 图片本地化    | 这是关键痛点。 网页中的 <img> 必须下载到本地，并在 Markdown 中替换为相对路径引用。 | 图片存储在 {Vault}/pic 目录，Markdown 引用显示正常。         |
| 智能交互   | 高亮与笔记    | 选中文本后悬浮菜单，支持“高亮”或“高亮+批注”。                | 页面刷新后无需保留（一次性会话），但导出时必须包含高亮文本和对应笔记。 |
| AI 增强    | 深度总结      | 基于提取的正文，生成核心观点总结。                           | 包含：1. 核心论点列表；2. 支撑据引用；3. Mermaid 逻辑图。    |
| 数据持久化 | 一键保存      | 将上述所有内容（MD文本 + 图片文件）原子性写入硬盘。          | 写入 Obsidian 指定目录，文件名不冲突。                       |



2. 核心业务流程 (The Workflow)
    - 用户在浏览网页时，可以给网页的内容 做高亮 和 笔记。


    - 用户在浏览器点击保存时，系统将按顺序执行以下流水线：

    DOM 萃取： 插件首先克隆当前页面 DOM，使用 Readability 算法剥离广告、侧边栏，仅保留文章核心 <article> 内容。
    资源本地化 (关键步骤)：
        插件遍历核心内容中的所有 <img> 标签。
        对每个图片 URL 发起 fetch 请求，获取二进制 Blob。
        将 Blob 转换为 Base64 字符串。
        生成唯一的文件名 hash（防止文件名冲突）。
        重要： 将 DOM 中的 src 属性预先替换为 Obsidian 的相对路径格式（如 ![](./assets/hash.png)）。

    智能增强：
        (并行) 将提取的纯文本发送给 LLM，请求生成包含 Mermaid 图表的总结。
        (并行) 收集用户在页面上留下的高亮和笔记数据。

    格式转换： 使用 Turndown 将处理过图片链接的 HTML 转换为 Markdown。

    数据投递： 将 Markdown 正文、AI 总结、Base64 图片集打包成一个 JSON Payload，发送给本地 Go Server。

    落盘： Go Server 接收请求，将图片解码存入 assets 目录，将文本拼接存入 .md 文件。

3. API 接口定义 (Interface)
我们定义唯一的写操作入口：
    Endpoint: POST /api/v1/save
    输入 (Request): 一个巨大的 JSON 包，包含：
        metadata: 标题、URL、来源域名。
        content: 已转换好的 Markdown 正文、AI 总结。
        assets: 一个数组，包含 { "filename": "abc.png", "base64": "..." }。
    输出 (Response):
      200 OK: 返回保存成功的本地绝对路径。
      500 Error: 返回具体的错误原因（如“图片写入失败”、“权限不足”）。

3. 目录结构规范 (Directory Structure)
    为了保证 Obsidian 库的整洁，我们采用“按日归档”的策略：
    根目录可以配置为：
        {Vault Root}/Inbox/WebClips/{YYYY-MM-DD}
    每个 Web Clip 都对应一个子目录，包含：
        assets/： 图片文件。
        {YYYY-MM-DD}.md： 笔记主文件。
```
Obsidian Vault Root/
├── Inbox/
│   └── WebClips/
│       └── 2025-05-24/  <-- 自动创建日期目录
│           ├── assets/  <-- 图片统一存放在此子目录
│           │   ├── image_hash_01.png
│           │   └── image_hash_02.png
│           └── 分布式系统原理.md  <-- 笔记主文件
```

5. 笔记内容排版规范 (Markdown Layout)
    最终生成的 Markdown 文件将遵循以下结构：

    YAML Frontmatter: 包含 title, url, date, tags。

    AI 摘要区: 包含核心观点列表和 Mermaid 思维导图。

    用户笔记区: (如果有) 汇总用户的所有高亮和批注。

    正文区: 原文内容的 Markdown 版本，其中的图片指向相对路径 ./assets/xxx.png。

深度架构决策点 (Critical Decision)
    在整理这份 Spec 时，针对 “大图片上传” 的问题，作为 MVP (最小可行性产品) 版本，我们决定暂时接受 Scheme A (单次大 JSON 传输)，但为了系统的鲁棒性，我们在代码层面必须增加两个保护机制：

    前端限制： 插件在打包图片时，如果单张图片超过 5MB，则自动放弃该图片的本地化（仅保留远程 URL），防止浏览器 Crash。

    后端流式读取： 虽然 HTTP Body 很大，但 Go 的处理能力足够强。我们将调整 Gin 的配置，允许较大的 MaxRequestBodySize。